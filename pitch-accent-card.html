<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>bruh</title>
    </head>

    <body>

        <p>The test() method returns true if it finds a match, otherwise it returns false.</p>
        <p>Click the button to search a string for the character "e".</p>

        <button onclick="drawPitchAccent('ジャック', 'LHH')">Try it</button>
        <!-- the height and width attributes are the number of pixels to draw on;
        when the style is set based on screen size, these pixels are scaled to match the screen, making it blurry.
        So, set the "virtual size" really high, and using the same aspect ratio of the style size, to make it
        not blurry or stretched.-->
        <canvas id="pitch-accent" height="2000" width="2000" style="width: 100%; height: 100%"></canvas>

        <script>

            function isGlottalStop(char) {
                return "っッ".includes(char);
            }

            function isCombiningForm(char) {
                return "ぁぃぅぇぉゃゅょァィゥェォャュョ".includes(char);
            }

            /**
             * bruh
             * @param word {string}
             * @param pattern {string}
             */
            function drawPitchAccent(word, pattern) {
                const primaryColor = 'black';
                const secondaryColor = 'white';
                const circScale = 10;

                const c = document.getElementById("pitch-accent");
                const ctx = c.getContext("2d");

                //let inc = c.width / pattern.length;
                //let workingHorizSpace = c.width / ((1 / (5 * pattern.length)) + 1); // working space padding for circle rad

                let inc = c.width / (pattern.length - 1 + (2 / circScale)); //calculated in samsung notes
                let circRad = inc / circScale;
                let curr = circRad;

                ctx.beginPath();
                ctx.moveTo(curr, pattern[0] === 'L' ? curr + inc : curr);
                ctx.fillStyle = primaryColor;
                ctx.strokeStyle = primaryColor;
                ctx.lineWidth = 2;

                for (let c of pattern) {
                    let y = (c.toUpperCase() === 'L' ? (circRad) + inc : circRad);

                    ctx.lineTo(curr, y);

                    if (c.toLowerCase() === c) { // is lowercase
                        ctx.stroke(); // finish old path
                        ctx.closePath(); // close old path

                        ctx.globalCompositeOperation = 'destination-out'; // set to erase mode

                        ctx.beginPath(); // start new path
                        ctx.moveTo(curr + circRad, y);
                        ctx.arc(curr, y, circRad, 0, 2 * Math.PI, false); // draw clear circle
                        ctx.moveTo(curr, y);
                        ctx.fill(); // fill clear circle with clear
                        ctx.closePath(); // close path

                        ctx.globalCompositeOperation = 'source-over'; // set to normal mode

                        ctx.beginPath(); //start new path
                    }

                    ctx.moveTo(curr + circRad, y);
                    ctx.arc(curr, y, circRad, 0, 2 * Math.PI, false);
                    ctx.moveTo(curr, y);

                    if (c.toUpperCase() === c) { // is uppercase
                        ctx.fill(); // only fill if uppercase, otherwise will just color over the erased part
                    }


                    //TODO lines are drawn through text bc of order
                    let stringToPrint = "";

                    if (0 < word.length) {
                        stringToPrint = word[0];

                        //TODO clean
                        if (1 < word.length && isGlottalStop(word[0])) {
                            stringToPrint += word[1];
                            if (2 < word.length && isCombiningForm(word[2])) {
                                stringToPrint += word[2];
                            }
                        } else if (isCombiningForm(word[1])) {
                            stringToPrint += word[1];
                        }
                    }

                    ctx.stroke(); // finish old path
                    ctx.closePath(); // close old path

                    // empty circles should never have text in them bc theyre release marks for particles
                    ctx.fillStyle = secondaryColor;
                    ctx.strokeStyle = secondaryColor;

                    let txtHeight = circRad * Math.sqrt(2) / stringToPrint.length; //TODO make more efficient
                    // Note: from square inscribed in triangle, corner to center = rad of circle,
                    // use as hypot for right triangle with b and h = side length/2, solve for side length using pyth

                    ctx.font = txtHeight + "px MS Mincho";
                    ctx.fillText(stringToPrint, curr - stringToPrint.length * (txtHeight / 2), y + (txtHeight / 4));

                    ctx.fillStyle = primaryColor;
                    ctx.strokeStyle = primaryColor;

                    ctx.beginPath(); //start new path
                    ctx.moveTo(curr, y);

                    word = word.substr(stringToPrint.length);
                    curr += inc;
                }
                ctx.stroke();
            }
        </script>

    </body>
</html>
